<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Проверка сервиса</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="page">
    <div class="content">
      <div class="logo">
        <img src="logo.svg" alt="Logo" onerror="this.style.display='none'">
      </div>

      <div id="checking-state" class="state">
        <h1 class="title">Секундочку</h1>
        <p class="subtitle">Проверяем доступность<br>мини-приложения...</p>
        <div class="divider"></div>
        <p class="note">Бот работает с 12:00 до 20:00 по МСК</p>
      </div>

      <div id="success-state" class="state" hidden>
        <h1 class="title">Всё в порядке</h1>
        <p class="subtitle">Через пару секунд<br>перенаправим вас.</p>
        <button id="open-btn" class="btn" type="button">
          <img src="star.svg" alt="" class="btn-icon">
          Перейти в Glint
        </button>
        <div class="divider"></div>
        <p class="note">Если будет страница с кнопкой "Visit Share" – просто нажмите на эту кнопку.</p>
      </div>

      <div id="error-state" class="state" hidden>
        <h1 class="title">Ой!</h1>
        <p class="subtitle">Мини-приложение<br>сейчас недоступно.</p>
        <div class="divider"></div>
        <p class="note">Бот работает с 12:00 до 20:00 по МСК</p>
      </div>
    </div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // Укажите базовый URL (без слэша в конце)
    const ZROK_URL = "https://glint.share.zrok.io";
    
    // Настройки времени
    const REDIRECT_DELAY_MS = 2500;
    const CHECK_TIMEOUT_MS = 5000; // Сколько ждем ответа от скрипта

    const checkingState = document.getElementById("checking-state");
    const successState = document.getElementById("success-state");
    const errorState = document.getElementById("error-state");
    const openBtn = document.getElementById("open-btn");

    // Инициализация Telegram WebApp
    let telegramInitData = null;
    try {
      if (window.Telegram && window.Telegram.WebApp) {
        telegramInitData = window.Telegram.WebApp.initData || null;
        window.Telegram.WebApp.expand(); // На всякий случай разворачиваем
      }
    } catch (e) {
      console.error("Telegram WebApp API error:", e);
    }

    // Формирование ссылки для редиректа
    const buildRedirectUrl = () => {
      let url = ZROK_URL;
      if (telegramInitData) {
        url += '#tgWebAppData=' + encodeURIComponent(telegramInitData);
      }
      return url;
    };

    // Переключение экранов
    const showState = (state) => {
      [checkingState, successState, errorState].forEach(el => el.setAttribute('hidden', ''));
      state.removeAttribute('hidden');
    };

    // Логика успеха
    const handleSuccess = () => {
      showState(successState);
      
      // Предзагрузка URL для ускорения
      const targetUrl = buildRedirectUrl();
      
      setTimeout(() => {
        window.location.href = targetUrl;
      }, REDIRECT_DELAY_MS);
    };

    // Логика ошибки
    const handleError = () => {
      showState(errorState);
    };

    // --- ГЛАВНАЯ ФУНКЦИЯ ПРОВЕРКИ (JSONP) ---
    const checkServerAvailability = () => {
      return new Promise((resolve, reject) => {
        // Уникальное имя функции, чтобы избежать кеширования и коллизий
        const callbackName = 'glint_health_' + Date.now();
        const script = document.createElement('script');
        let isResolved = false;

        // Создаем глобальную функцию, которую вызовет сервер
        window[callbackName] = (data) => {
          if (isResolved) return;
          isResolved = true;
          cleanup();
          
          if (data && data.status === 'ok') {
            resolve();
          } else {
            reject();
          }
        };

        // Очистка DOM и глобальной области
        const cleanup = () => {
          if (script.parentNode) script.parentNode.removeChild(script);
          delete window[callbackName];
        };

        // Если скрипт не загрузился или сервер вернул ошибку
        script.onerror = () => {
          if (isResolved) return;
          isResolved = true;
          cleanup();
          reject();
        };

        // Таймаут (если Zrok висит или вернул HTML, который не исполнился как JS)
        setTimeout(() => {
          if (isResolved) return;
          isResolved = true;
          cleanup();
          reject(); // Считаем ошибкой по таймауту
        }, CHECK_TIMEOUT_MS);

        // Добавляем параметр времени для обхода кеша
        script.src = `${ZROK_URL}/health_jsonp?callback=${callbackName}&_=${Date.now()}`;
        document.body.appendChild(script);
      });
    };

    // Запуск проверки при загрузке
    checkServerAvailability()
      .then(() => {
        handleSuccess();
      })
      .catch(() => {
        handleError();
      });

    // Обработчик кнопки ручного перехода
    openBtn.addEventListener("click", () => {
      window.location.href = buildRedirectUrl();
    });
  </script>
</body>
</html>
